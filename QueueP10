# 10. Dada una cola con las notificaciones de las aplicaciones de redes sociales de un Smartphone,
# de las cual se cuenta con la hora de la notificación, la aplicación que la emitió y el mensaje,
# resolver las siguientes actividades:
# a. escribir una función que elimine de la cola todas las notificaciones de Facebook;
# b. escribir una función que muestre todas las notificaciones de Twitter, cuyo mensaje incluya
# la palabra ‘Python’, si perder datos en la cola;
# c. utilizar una pila para almacenar temporáneamente las notificaciones producidas entre las
# 11:43 y las 15:57, y determinar cuántas son.

cola_notificaciones = [
    {"hora": "10:15", "app": "Facebook", "mensaje": "Tienes 3 nuevas reacciones."},
    {"hora": "11:10", "app": "Instagram", "mensaje": "Nueva historia de tu amigo."},
    {"hora": "11:50", "app": "Twitter",
        "mensaje": "Aprendiendo Python con ejercicios de recursión."},
    {"hora": "12:05", "app": "WhatsApp", "mensaje": "¿Te juntás hoy?"},
    {"hora": "13:20", "app": "Facebook",
        "mensaje": "Nuevo comentario en tu publicación."},
    {"hora": "14:10", "app": "Twitter",
        "mensaje": "Python es clave para data science."},
    {"hora": "15:30", "app": "TikTok", "mensaje": "Nuevo video recomendado."},
    {"hora": "16:05", "app": "Twitter", "mensaje": "Hoy no hablo de programación."},
    {"hora": "17:45", "app": "Facebook",
        "mensaje": "Recordatorio: mira tus recuerdos."},
    {"hora": "18:20", "app": "Telegram", "mensaje": "Mensaje en el grupo de la facu."}
]


class Queue():

    def __init__(self):
        self.__element = []

    def attention(self):
        if self.__element:
            return self.__element.pop(0)
        else:
            return None

    def on_front(self):
        return self.__element[0] if self.__element else None

    def size(self):
        return len(self.__element)

    def arrive(self, value):
        self.__element.append(value)

    def show(self):
        for n in self.__element:
            print(n)


mi_Queue = Queue()

for notificaciones in cola_notificaciones:
    mi_Queue.arrive(notificaciones)

# A


def eliminar_facebook(cola):
    aux = Queue()

    # Recorremos toda la cola original
    while cola.size() > 0:
        noti = cola.attention()
        if noti["app"] != "Facebook":    # filtramos
            aux.arrive(noti)             # enqueue en auxiliar

    # Devolvemos todo a la cola original
    while aux.size() > 0:
        cola.arrive(aux.attention())


# B
def Twitter_Python(self):
    aux = []

    while self.size() > 0:
        notif = self.attention()

        if notif["app"] == "Twitter" and "Python" in notif["mensaje"]:
            print(f"{notif['hora']} - {notif['app']}: {notif['mensaje']}")

        aux.append(notif)

    # Restaurar la cola
    for notif in aux:
        self.arrive(notif)

# C
def notificaciones_hora(self):
    aux = Queue()   # para reconstruir la cola
    pila_temp = []  # pila (stack) temporal
    contador = 0

    while self.size() > 0:
        notif = self.attention()

        if "11:43" <= notif["hora"] <= "15:57":
            pila_temp.append(notif)  # push
            contador += 1

        aux.arrive(notif)

    # Restaurar la cola original
    while aux.size() > 0:
        self.arrive(aux.attention())

    print(f"Cantidad de notificaciones entre 11:43 y 15:57: {contador}")
    for notif in pila_temp:
        print(notif)
    
    
    




# A
print("Notificaciones sin Facebook")
eliminar_facebook(mi_Queue)
mi_Queue.show()

# B
print("Notificaciones de Twitter con la palabra Python")
Twitter_Python(mi_Queue)

# C
print("Notificaciones entre las 11:43 y las 15:57")
notificaciones_hora(mi_Queue)
