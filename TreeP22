# 22. Parta de la base del árbol genealógico “greek-gods” (n-arios) que se observa en el siguiente link:
# https://drive.google.com/file/d/13lMB6A2k4zO2zq-wuTgdxZdgwUKLl4Tr/view?usp=sharing, y
# utilice la transformada de Knuth para convertirlo en un árbol binario que permita realizar las
# siguiente actividades (no se deben utilizar árboles balanceados):

# a. la raíz del árbol debe ser Urano;
# b. además del nombre de los dioses, deberá cargar una breve descripción de quien es o lo que
# representa, no más de 20 palabras;
# c. listar el árbol por niveles, es decir, mostrando primero los hermanos. Para esto desarrolle
# una función barrido llamada “hermanos(raíz)” que devuelva todos los hijos derechos de
# un determinado nodo de un árbol general transformado a binario;
# d. solo se representarán las relaciones padre-hijo, a excepción de los dioses que en la imagen
# no tengan padre, –en este caso se deberá cargar la relación madre-hijo–, en los demás la
# madre será almacenada en un campo del nodo;
# e. dado el nombre de un dios mostrar los hijos de este;
# f. dado el nombre de un dios mostrar su nombre, padre, madre, hermanos y sus hijos;
# g. realizar un barrido inorden, preorden y por nivel de dicho árbol;
# h. realizar un barrido inorden mostrando el nombre de cada dios y el de su madre;
# i. mostrar todos los ancestros de un determinado dios;
# j. generar un bosque eliminando el nodo Uranos:
# I. determinar cuántos árboles forman dicho bosque,
# II. realizar un barrido inorden de cada árbol del bosque,
# III. determinar cuántos nodos hay en cada árbol y cuál es el nombre del dios del nodo raíz del árbol más grande;
# k. mostrar todos los hijos de Tea.

from typing import Any, Optional
from queue import Queue


class GodBinaryTree:

    class Nodo:
        def __init__(self, value: Any, desc: str = "", mother: Optional[str] = None, father: Optional[str] = None):
            self.value = value
            self.desc = desc              # descripción breve
            self.mother = mother          # madre
            self.father = father          # padre
            self.left = None              # primer hijo (Knuth)
            self.right = None             # hermano derecho (Knuth)

    def __init__(self):
        self.root = None

    # C
    def hermanos(self, nodo):  # Simplemente imprime todos los hermanos derechos del nodo que le pasamos para q sean los hijos es a lz izquierda nomas
        actual = nodo
        while actual is not None:
            print(actual.value)
            actual = actual.right
    # E

    # Simplemente busca el nodo correcto e imprime todo lo que este a la izquierda(hi jos)
    def mostrar_hijos(self, nombre):
        def buscar_nodo(root, nombre):
            if root is None:
                return None
            if root.value == nombre:
                return root
            # Busca en hijos e hermanos
            res = buscar_nodo(root.left, nombre)
            if res:
                return res
            return buscar_nodo(root.right, nombre)

        nodo = buscar_nodo(self.root, nombre)
        if nodo and nodo.left:
            hijo = nodo.left
            print(f"Hijos de {nombre}:")
            while hijo:
                print(f"- {hijo.value}: {hijo.desc}")
                hijo = hijo.right
        elif nodo:
            print(f"{nombre} no tiene hijos.")
        else:
            print(f"{nombre} no encontrado.")

    # F
    # Primero busca el nodo correcto e imoprime su informacion y luego dos while para imprimir todo a la izquierda y a la derecha
    def buscar_y_mostrar(self, nombre):
        def buscar_nodo(root, nombre):
            if root is None:
                return None
            if root.value == nombre:
                return root
            res = buscar_nodo(root.left, nombre)
            if res:
                return res
            return buscar_nodo(root.right, nombre)

        nodo = buscar_nodo(self.root, nombre)
        if nodo:
            print(f"Nombre: {nodo.value}")
            print(f"Descripción: {nodo.desc}")
            print(f"Padre: {nodo.father if nodo.father else 'Desconocido'}")
            print(f"Madre: {nodo.mother if nodo.mother else 'Desconocido'}")
            # Hermanos
            print("Hermanos:")
            hermano = nodo.right
            if hermano:
                while hermano:
                    print(f"- {hermano.value}")
                    hermano = hermano.right
            else:
                print("No tiene hermanos derechos.")
            # Hijos
            print("Hijos:")
            hijo = nodo.left
            if hijo:
                while hijo:
                    print(f"- {hijo.value}")
                    hijo = hijo.right
            else:
                print("No tiene hijos.")
        else:
            print(f"{nombre} no encontrado.")

    # G Esto son los metodos de barrido que dimos simplemente
    # Barrido inorden (izquierda, raíz, derecha)
    def inorden(self):
        def __inorden(root):
            if root is not None:
                __inorden(root.left)
                print(root.value)
                __inorden(root.right)
        __inorden(self.root)

    # Barrido preorden (raíz, izquierda, derecha)
    def preorden(self):
        def __preorden(root):
            if root is not None:
                print(root.value)
                __preorden(root.left)
                __preorden(root.right)
        __preorden(self.root)

    # Barrido por nivel (BFS)
    def por_nivel(self):
        if self.root is None:
            return
        q = Queue()
        q.put(self.root)
        while not q.empty():
            nodo = q.get()
            print(nodo.value)
            # En Knuth, hijos son el izquierdo y hermanos derechos
            hijo = nodo.left
            while hijo:
                q.put(hijo)
                hijo = hijo.right

    # H
    # Es un inorden normal pero mostrando el nombre de la madre
    def inorden_nombre_madre(self):
        def __inorden(root):
            if root is not None:
                __inorden(root.left)
                print(
                    f"{root.value} - Madre: {root.mother if root.mother else 'Desconocida'}")
                __inorden(root.right)
        __inorden(self.root)

    # I
    # Basicamente lo que hace es que busca el nodo y cuando pasa por un nodo a otro lo guarda en una cola
    def mostrar_ancestros(self, nombre):
        def buscar_camino(root, nombre):
            if root is None:
                return None
            q = Queue()
            camino = []
            q.put((root, []))
            while not q.empty():
                nodo, recorrido = q.get()
                if nodo.value == nombre:
                    return recorrido + [nodo]
                # Agrega el hijo izquierdo (descendiente) y hermano derecho (Knuth)
                if nodo.left:
                    q.put((nodo.left, recorrido + [nodo]))
                if nodo.right:
                    q.put((nodo.right, recorrido))
            return None

        camino = buscar_camino(self.root, nombre)
        if camino:
            print(f"Ancestros de {nombre}:")
            for ancestro in camino[:-1]:
                print(f"- {ancestro.value}")
        else:
            print(f"{nombre} no encontrado.")

    # J i
    def eliminar_raiz(self):
        #limina la raíz (Urano) y devuelve la lista de subárboles (bosque)
        if self.root is None:
            return []

        bosque = []
        hijo = self.root.left   # primer hijo de Urano
        while hijo:
            bosque.append(hijo)
            hijo = hijo.right   # avanza a la derecha que estan los hermanos de cronos 
        self.root = None  # Se elimina a urano 
        return bosque
    
    #K
    def mostrar_hijos_de_tea(self):
        def buscar_nodo(root, nombre):
            if root is None:
                return None
            if root.value == nombre:
                return root
            res = buscar_nodo(root.left, nombre)
            if res:
                return res
            return buscar_nodo(root.right, nombre)
        
        nodo_hiperion = buscar_nodo(self.root, "Hiperión")
        if nodo_hiperion and nodo_hiperion.left:
            hijo = nodo_hiperion.left
            print("Hijos de Tea:")
            while hijo:
                print(f"- {hijo.value}: {hijo.desc}")
                hijo = hijo.right
        elif nodo_hiperion:
            print("Tea no tiene hijos.")
        else:
            print("Tea no encontrado.")
    


# ======================
# A) Raiz urano
# ======================
arbol = GodBinaryTree()
arbol.root = GodBinaryTree.Nodo(
    "Urano", "Cielo primordial, padre de los Titanes.")

# ======================
# Hijos de Urano y Gea
# ======================
cronos = GodBinaryTree.Nodo(
    "Cronos", "Titán del tiempo, derrocó a Urano.", mother="Gea", father="Urano")
oceano = GodBinaryTree.Nodo(
    "Océano", "Titán del río que rodea el mundo.", mother="Gea", father="Urano")
ceo = GodBinaryTree.Nodo(
    "Ceo", "Titán del intelecto y la sabiduría.", mother="Gea", father="Urano")
crio = GodBinaryTree.Nodo(
    "Crío", "Titán de los rebaños y constelaciones.", mother="Gea", father="Urano")
hiperion = GodBinaryTree.Nodo(
    "Hiperión", "Titán de la luz y el sol.", mother="Gea", father="Urano")
japeto = GodBinaryTree.Nodo(
    "Jápeto", "Titán de la mortalidad y padre de Prometeo.", mother="Gea", father="Urano")
tea = GodBinaryTree.Nodo("Tea", "Titánide de la luz.",
                         mother="Gea", father="Urano")
rea = GodBinaryTree.Nodo(
    "Rea", "Titánide de la fertilidad y madre de los olímpicos.", mother="Gea", father="Urano")
temis = GodBinaryTree.Nodo(
    "Temis", "Titánide de la justicia y el orden divino.", mother="Gea", father="Urano")
mnemosine = GodBinaryTree.Nodo(
    "Mnemósine", "Titánide de la memoria.", mother="Gea", father="Urano")
febe = GodBinaryTree.Nodo(
    "Febe", "Titánide de la luna y la profecía.", mother="Gea", father="Urano")
tetis = GodBinaryTree.Nodo(
    "Tetis", "Titánide del agua dulce.", mother="Gea", father="Urano")

# Encadenamos con Knuth
arbol.root.left = cronos
cronos.right = oceano
oceano.right = ceo
ceo.right = crio
crio.right = hiperion
hiperion.right = japeto
japeto.right = tea
tea.right = rea
rea.right = temis
temis.right = mnemosine
mnemosine.right = febe
febe.right = tetis

# ======================
# Hijos de Cronos y Rea
# ======================
zeus = GodBinaryTree.Nodo(
    "Zeus", "Rey de los dioses, dios del cielo y trueno.", mother="Rea", father="Cronos")
hera = GodBinaryTree.Nodo(
    "Hera", "Diosa del matrimonio y la familia.", mother="Rea", father="Cronos")
poseidon = GodBinaryTree.Nodo(
    "Poseidón", "Dios del mar y los terremotos.", mother="Rea", father="Cronos")
hades = GodBinaryTree.Nodo(
    "Hades", "Dios del inframundo y los muertos.", mother="Rea", father="Cronos")
demeter = GodBinaryTree.Nodo(
    "Deméter", "Diosa de la agricultura y la fertilidad.", mother="Rea", father="Cronos")
hestia = GodBinaryTree.Nodo(
    "Hestia", "Diosa del hogar y la familia.", mother="Rea", father="Cronos")

# Encadenamos hijos de Cronos
cronos.left = zeus
zeus.right = hera
hera.right = poseidon
poseidon.right = hades
hades.right = demeter
demeter.right = hestia

# ======================
# Hijos de Hiperión y Tea
# ======================
helios = GodBinaryTree.Nodo(
    "Helios", "Dios del sol.", mother="Tea", father="Hiperión")
selene = GodBinaryTree.Nodo(
    "Selene", "Diosa de la luna.", mother="Tea", father="Hiperión")
eos = GodBinaryTree.Nodo("Eos", "Diosa del amanecer.",
                         mother="Tea", father="Hiperión")

# Encadenamos
hiperion.left = helios
helios.right = selene
selene.right = eos

# ======================
# Hijos de Jápeto
# ======================
prometeo = GodBinaryTree.Nodo(
    "Prometeo", "Creador de los humanos, dio el fuego.", father="Jápeto")
epimeteo = GodBinaryTree.Nodo("Epimeteo", "Aceptó a Pandora.", father="Jápeto")
atlas = GodBinaryTree.Nodo(
    "Atlas", "Condenado a sostener el cielo.", father="Jápeto")

# Encadenamos
japeto.left = prometeo
prometeo.right = epimeteo
epimeteo.right = atlas

# ======================
# Hijos de Océano y Tetis
# ======================
pleione = GodBinaryTree.Nodo(
    "Pleione", "Náyade, madre de las Pléyades.", mother="Tetis", father="Océano")
oceano.left = pleione

# ======================
# Hijos de Ceo y Febe
# ======================
leto = GodBinaryTree.Nodo(
    "Leto", "Madre de Apolo y Artemisa.", mother="Febe", father="Ceo")
ceo.left = leto

# ======================
# Hijos de Atlas y Pelone
# ======================
maia = GodBinaryTree.Nodo("Maia", "Madre de Hermes.",
                          mother="Pleione", father="Atlas")
atlas.left = maia


# ======================
# Hijos de Zeus y Leto
# ======================
apolo = GodBinaryTree.Nodo(
    "Apolo", "Dios del sol, música y profecía.", mother="Leto", father="Zeus")
artemisa = GodBinaryTree.Nodo(
    "Artemisa", "Diosa de la caza y la luna.", mother="Leto", father="Zeus")
zeus.left = apolo
apolo.right = artemisa

# ======================
# Hijos de Zeus y Hera
# ======================
ares = GodBinaryTree.Nodo(
    "Ares", "Dios de la guerra, la violencia y la masacre.", mother="Hera", father="Zeus")
hefesto = GodBinaryTree.Nodo(
    "Hefesto", "Dios del fuego, la forja, los herreros y los artesanos.", mother="Hera", father="Zeus")
artemisa.right = ares
ares.right = hefesto

# ======================
# Hijos de Zeus y Deméter
# ======================
perses = GodBinaryTree.Nodo(
    "Perses", "Titán de la destrucción.", mother="Deméter", father="Zeus")
hefesto.right = perses


# ======================
# Hijos de Zeus y Semele
# ======================
dionisio = GodBinaryTree.Nodo(
    "Dionisio", "Dios del vino, la fiesta y el teatro.", mother="Semele", father="Zeus")
perses.right = dionisio

# ======================
# Hijos de Zeus y Maia
# ======================
hermes = GodBinaryTree.Nodo(
    "Hermes", "Dios mensajero, del comercio y los viajeros.", mother="Maia", father="Zeus")
dionisio.right = hermes

# ======================
# Hijos de Ares y Afrodita
# ======================

fobos = GodBinaryTree.Nodo(
    "Fobos", "Personificación del miedo.", mother="Afrodita", father="Ares")
deimos = GodBinaryTree.Nodo(
    "Deimos", "Personificación del terror.", mother="Afrodita", father="Ares")
eros = GodBinaryTree.Nodo(
    "Eros", "Dios del amor y la atracción.", mother="Afrodita", father="Ares")
himero = GodBinaryTree.Nodo(
    "Himero", "Personificación del deseo sexual.", mother="Afrodita", father="Ares")
ares.left = fobos
fobos.right = deimos
deimos.right = eros
eros.right = himero

# ======================
# Hijos de Hermes y Afrodita
# ======================
hermafrodito = GodBinaryTree.Nodo(
    "Hermafrodito", "Fusión de Hermes y Afrodita.", mother="Afrodita", father="Hermes")
hermes.left = hermafrodito

# ======================
# Hijos de Hermes y Penélope
# ======================

pan = GodBinaryTree.Nodo(
    "Pan", "Dios de la naturaleza, los pastores y el rebaño.", mother="Penélope", father="Hermes")
hermafrodito.right = pan


# C
arbol.hermanos(zeus.left)
# E
arbol.mostrar_hijos("Zeus")
# F
arbol.buscar_y_mostrar("Cronos")
# G
arbol.inorden()
arbol.preorden()
arbol.por_nivel()

# H
arbol.inorden_nombre_madre()

# i
arbol.mostrar_ancestros("Zeus")


# # J ,I ,II, III
# bosque = arbol.eliminar_raiz()  # Se elimina a Urano y devuelve el bosque con los subárboles
# print("Barrido inorden de cada árbol del bosque:")
# for subarbol in bosque:
#     def inorden(root, is_root=True):
#         if root is not None:
#             inorden(root.left, False)
#             if is_root:
#                 print(f"{root.value} (nodo raíz)")        Esta comentado pq me elimina la raiz y sino no anda nada 
#             else:
#                 print(root.value)
#             inorden(root.right, False)
#     inorden(subarbol)
#     print("-" * 30)
    
arbol.mostrar_hijos_de_tea()
